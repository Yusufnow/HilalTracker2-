<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Prof. Hilal Rechner & Himmelsansicht</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; overflow: hidden; }
        
        /* Layout */
        #map { width: 100%; height: 60vh; background: #000; z-index: 1; }
        #sky-view { 
            width: 100%; 
            height: 40vh; 
            background: linear-gradient(to bottom, #0f172a 0%, #312e81 60%, #c084fc 100%); 
            position: relative; 
            border-top: 4px solid #fff;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* Schwebendes Kontrollpanel */
        .controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 15px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="date"] { padding: 8px; border-radius: 15px; border: 1px solid #ccc; }
        
        button.calc-btn {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
        }
        button.calc-btn:disabled { background: #ccc; cursor: wait; }

        /* Loader */
        .loader {
            position: fixed; top: 0; left: 0; width: 0%; height: 4px;
            background: #00e5ff; z-index: 2000; transition: width 0.2s;
        }

        /* Sky View Labels */
        .sky-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            pointer-events: none;
        }
        
        canvas {
            display: block;
        }

        .leaflet-control-geocoder { border-radius: 20px !important; }
    </style>
</head>
<body>

    <div class="loader" id="loader"></div>

    <div class="controls">
        <input type="date" id="datePicker">
        <button class="calc-btn" onclick="calculateMap()">üöÄ Berechnen</button>
    </div>

    <div id="map"></div>

    <div id="sky-view">
        <div class="sky-info" id="skyInfoText">W√§hle einen Ort auf der Karte...</div>
        <canvas id="skyCanvas"></canvas>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>

    <script>
        // --- 1. SETUP ---
        const map = L.map('map', { center: [20, 0], zoom: 2 });
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Esri'
        }).addTo(map);

        // Suchfunktion
        const geocoder = L.Control.geocoder({
            defaultMarkGeocode: false
        }).on('markgeocode', function(e) {
            const center = e.geocode.center;
            map.setView(center, 6);
            updateSkyView(center.lat, center.lng, e.geocode.name);
        }).addTo(map);

        // Klick Event auf Karte
        map.on('click', function(e) {
            updateSkyView(e.latlng.lat, e.latlng.lng, "Gew√§hlter Ort");
        });

        const layers = {
            green: L.layerGroup().addTo(map),
            magenta: L.layerGroup().addTo(map),
            blue: L.layerGroup().addTo(map)
        };

        // Canvas Setup
        const canvas = document.getElementById('skyCanvas');
        const ctx = canvas.getContext('2d');
        let selectedLocation = null;

        document.getElementById('datePicker').valueAsDate = new Date();

        // Canvas Gr√∂√üe anpassen
        function resizeCanvas() {
            const container = document.getElementById('sky-view');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if(selectedLocation) updateSkyView(selectedLocation.lat, selectedLocation.lon, selectedLocation.name);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();


        // --- 2. HIMMELSANSICHT LOGIK (Der neue Teil) ---

        function updateSkyView(lat, lon, name) {
            selectedLocation = { lat, lon, name };
            const dateInput = document.getElementById('datePicker').value;
            const date = new Date(dateInput);
            
            // 1. Sonnenuntergang berechnen
            const observer = new Astronomy.Observer(lat, lon, 0);
            
            // Wir suchen den Sonnenuntergang am gew√§hlten Tag
            // Wir setzen die Zeit auf Mittag, um den n√§chsten Untergang zu finden
            date.setUTCHours(12,0,0,0);
            const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, 1, date, 1);
            
            if (!sunset) {
                document.getElementById('skyInfoText').innerHTML = `Kein Sonnenuntergang (Polartag/nacht) in<br><b>${name}</b>`;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }

            const time = sunset.date; // Zeitpunkt des Untergangs
            
            // Anzeige Info
            const localTime = time.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            document.getElementById('skyInfoText').innerHTML = 
                `<b>${name}</b><br>Sonnenuntergang: ${localTime}<br>Blick Richtung West`;

            // 2. Positionen berechnen
            const bodies = [
                { name: 'Sonne', type: 'Sun', color: '#FFD700', radius: 10 },
                { name: 'Mond', type: 'Moon', color: '#FFF', radius: 8 },
                { name: 'Venus', type: 'Venus', color: '#00FFFF', radius: 4 },
                { name: 'Jupiter', type: 'Jupiter', color: '#FFDAB9', radius: 4 },
                { name: 'Saturn', type: 'Saturn', color: '#F4A460', radius: 3 },
                { name: 'Mars', type: 'Mars', color: '#FF4500', radius: 3 },
                { name: 'Merkur', type: 'Mercury', color: '#B0C4DE', radius: 2 }
            ];

            const positions = [];
            
            // Wir definieren das Blickfeld (FOV)
            // Zentrum: Westen (270 Grad Azimut)
            // Wir zeigen 60 Grad Weite an (240 bis 300)
            const centerAz = sunset.azimuth || 270; // Nutze echten Sonnenuntergangs-Azimut als Zentrum
            const fov = 60; 
            const pxPerDeg = canvas.width / fov;

            bodies.forEach(body => {
                const astroBody = Astronomy.Body[body.type];
                const equator = Astronomy.Equator(astroBody, time, observer, true, true);
                const horizon = Astronomy.Horizon(time, observer, equator.ra, equator.dec, 'normal');
                
                positions.push({
                    ...body,
                    az: horizon.az,
                    alt: horizon.alt,
                    dist: equator.dist // Entfernung (f√ºr Mondgr√∂√üe, hier vereinfacht)
                });
            });

            // 3. Zeichnen
            drawSky(positions, centerAz, pxPerDeg);
        }

        function drawSky(bodies, centerAz, pxPerDeg) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Horizont Linie zeichnen
            const horizonY = canvas.height * 0.8; // Horizont bei 80% der H√∂he
            
            // Linie
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            ctx.lineTo(canvas.width, horizonY);
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // K√∂rper zeichnen
            bodies.forEach(body => {
                // X-Position berechnen
                let azDiff = body.az - centerAz;
                // Korrektur f√ºr 360-Grad Sprung
                if (azDiff > 180) azDiff -= 360;
                if (azDiff < -180) azDiff += 360;

                const x = (canvas.width / 2) + (azDiff * pxPerDeg);
                const y = horizonY - (body.alt * pxPerDeg); // Y geht nach unten, also minus

                // Nur zeichnen wenn im Bild
                if (x > -50 && x < canvas.width + 50 && y > -50 && y < canvas.height + 50) {
                    
                    // Zeichnen
                    ctx.beginPath();
                    
                    if (body.type === 'Moon') {
                        // Mond speziell (simuliert)
                        ctx.fillStyle = body.color;
                        ctx.arc(x, y, body.radius * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        // Kleiner Schatten f√ºr Phase (sehr vereinfacht: Neumond)
                        ctx.fillStyle = 'rgba(0,0,0,0.5)';
                        ctx.beginPath();
                        ctx.arc(x - 2, y - 2, body.radius * 1.3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Sterne/Planeten/Sonne
                        ctx.fillStyle = body.color;
                        ctx.arc(x, y, body.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Schein (Glow)
                        ctx.beginPath();
                        ctx.arc(x, y, body.radius * 3, 0, Math.PI * 2);
                        ctx.fillStyle = body.color;
                        ctx.globalAlpha = 0.2;
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }

                    // Label/Text
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    // Text unter dem Objekt (au√üer wenn unter Horizont)
                    const textY = y > horizonY ? y - 15 : y + 20;
                    ctx.fillText(body.name, x, textY);
                }
            });
        }

        // --- 3. KARTEN BERECHNUNG (Alte Logik) ---

        function getMoonVisibility(lat, lon, dateObj) {
            const date = new Date(dateObj);
            date.setUTCHours(12, 0, 0, 0);
            const observer = new Astronomy.Observer(lat, lon, 0);
            const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, 1, date, 1);
            if (!sunset) return null;

            const time = sunset.date;
            const sunPos = Astronomy.Equator(Astronomy.Body.Sun, time, observer, true, true);
            const moonPos = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, true);
            const sunHor = Astronomy.Horizon(time, observer, sunPos.ra, sunPos.dec, 'normal');
            const moonHor = Astronomy.Horizon(time, observer, moonPos.ra, moonPos.dec, 'normal');

            const altMoon = moonHor.alt;
            const elongation = Astronomy.AngleBetween(sunPos.vec, moonPos.vec);
            
            // Odeh Logik
            let V = altMoon - (-0.1018 * Math.pow(elongation, 2) + 1.6787 * elongation - 5.5704);

            if (altMoon <= 0.5 || elongation < 7.0) return 'invisible'; 
            if (V >= 5.6) return 'green';
            if (V >= 2.0) return 'magenta';
            if (V >= -0.9) return 'blue';
            return 'invisible';
        }

        async function calculateMap() {
            const btn = document.querySelector('.calc-btn');
            const loader = document.getElementById('loader');
            const dateInput = document.getElementById('datePicker').value;
            
            if (!dateInput) return alert("Bitte Datum w√§hlen");
            btn.disabled = true;
            layers.green.clearLayers();
            layers.magenta.clearLayers();
            layers.blue.clearLayers();
            
            const step = 2; 
            const date = new Date(dateInput);

            const processChunk = (latStart) => {
                for (let lat = latStart; lat > -60; lat -= step) {
                    if (lat < latStart && (latStart - lat) % 5 === 0) {
                        setTimeout(() => processChunk(lat), 0);
                        return;
                    }
                    for (let lon = -180; lon < 180; lon += step) {
                        const result = getMoonVisibility(lat, lon, date);
                        if (result !== 'invisible' && result !== null) {
                            let color = result === 'green' ? '#00FF00' : (result === 'magenta' ? '#FF00FF' : '#0055FF');
                            L.circleMarker([lat, lon], {
                                radius: 3, fillColor: color, color: color, weight: 0, opacity: 0.6, fillOpacity: 0.6
                            }).addTo(layers[result]);
                        }
                    }
                    loader.style.width = (Math.abs(60 - lat) / 120 * 100) + "%";
                }
                btn.disabled = false;
                loader.style.width = "0%";
            };
            processChunk(60); 
        }

        setTimeout(calculateMap, 1000);
    </script>
</body>
</html>
